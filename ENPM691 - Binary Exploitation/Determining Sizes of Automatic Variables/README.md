# Memory Layout Analysis

## Abstract
This assignment focuses on understanding variable locations and enhancing debugging techniques by analyzing assembly code and memory addresses. By examining `address_layout.c`, the study investigates how variable declaration types influence the placement of variables in memory within a single-file structure. Utilizing the Pwndbg debugger, the analysis reveals how the compiler generates assembly code to manage variable storage differently based on their context. The results highlight distinct patterns in memory allocation for various variable types, emphasizing the effects of linking multiple files. The discussion elaborates on these findings, providing explanations for the compiler’s choices in variable placement and their implications for effective debugging and performance optimization.

---

## Usage Instructions

### Clone the Repository
```bash
git clone <repository_url>
cd <repository_directory>
```

### Compile the Program
```bash
gcc -m32 -g address_layout.c global_vars.c -o address_layout
```

### Analyze with GDB
1. Launch GDB:
   ```bash
   gdb ./address_layout
   ```
2. Run the program inside GDB:
   ```bash
   run
   ```
3. Use the custom Python script to automate analysis:
   ```bash
   source analyze_memory.py
   analyze_memory
   ```

### Manual Debugging (Optional)
- Use `disassemble` to inspect assembly code.
- Use `info variables` to list all variables and their memory locations.
- Use `x/x` to examine specific memory addresses.

---

## Results
The following are insights derived from analyzing the compiled program. Note that these are demo values obtained during a specific run and may vary depending on the system and compiler settings:

### Assembly Insights

#### Global Variables
- **Uninitialized Variables**: Reside in the `.bss` segment, accessed via relative addressing using `lea`. Example: `global_uninit_var_1` at `0x56559014`.
- **Initialized Variables**: Stored in the `.data` segment, accessed similarly. Example: `global_var_1` at `0x5655900c`.

#### Local Variables
- Stored on the stack, accessed using the base pointer (`rbp`) with offsets. Example: `local_var_1` at `rbp-0x14` and `local_var_2` at `rbp-0x18`.

#### Static Variables
- Stored in the `.data` segment, maintain values across function calls. Example: `static_var_1` at `0x5655901c`.

#### Heap Variables
- Allocated using `malloc`, addresses stored on the stack. Example: `ptr_1` allocated at `rbp-0x8` with heap address range between `0x5655a000` and `0x5657c000`.

---

## Key Takeaways
1. **Memory Segmentation**: Variables are stored in distinct memory segments (“.bss”, “.data”, stack, and heap) based on their type and initialization.
2. **Assembly Access**: Variables are accessed via specific assembly instructions like `lea` and offsets from `rbp`.
3. **Dynamic Memory**: Heap variables extend beyond function lifetimes, making them suitable for dynamic allocations.

---

## Disclaimer
This exercise automates memory analysis using GDB and Python scripting for efficiency. However, manual debugging is essential for gaining a deeper understanding of memory layout and compiler behavior. The provided results and addresses are examples and may vary in different environments or configurations.

---

## Author
**T3rminux**
Ethical Hacker & Cybersecurity Professional

