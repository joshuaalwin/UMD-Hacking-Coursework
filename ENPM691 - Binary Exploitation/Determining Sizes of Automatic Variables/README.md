# Memory Layout Analysis

## Abstract
This homework assignment demonstrates a method for determining the sizes of automatic variables in C by analyzing the differences in their memory addresses. By examining various data types, the study provides insights into memory allocation and layout in C programming. This approach offers an alternative to the traditional `sizeof()` operator, contributing to a deeper understanding of low-level memory management.

## Usage Instructions

### Clone the Repository
```bash
git clone <repository_url>
cd <repository_directory>
```

### Compile the Program
```bash
gcc -m32 -g variables.c -o variables
```

### Analyze with GDB

#### Launch GDB:
```bash
gdb ./variables
```

#### Run the program inside GDB:
```bash
run
```

#### Use the custom Python script to automate analysis (Optional):
```bash
source analyze_data_types.py
analyze_data_types
```

#### Manual Debugging (Optional):
- Use `disassemble` to inspect assembly code.
- Use `info variables` to list all variables and their memory locations.
- Use `x/x` to examine specific memory addresses.

### Modify the Source Code
To explore different data types or test modifications, make changes to the source code and recompile.

#### Steps:
1. Edit the `memory_layout.c` file to add or modify variables.
2. Recompile the code.
3. Analyze the memory layout and size calculations.

## Results

### Data Types and Memory Addresses
The addresses of the automatic variables were successfully retrieved, and their sizes were calculated using the memory difference method. Table I shows the memory addresses of the variables, and Table II presents the size calculation based on the differences between consecutive addresses.

#### Table I: Data Types and Addresses
| Data Type      | Address          |
|----------------|------------------|
| Char           | 0x7fffffffdbbd  |
| Short          | 0x7fffffffdbbe  |
| Int            | 0x7fffffffdbc0  |
| Float          | 0x7fffffffdbc4  |
| Double         | 0x7fffffffdbc8  |
| Long           | 0x7fffffffdbd0  |
| Long Long      | 0x7fffffffdbd8  |
| Long Double    | 0x7fffffffde0   |
| Long Double (i)| 0x7fffffffdf0   |

#### Table II: Variable Sizes Calculated by Memory Address Difference
| Data Type      | Address Difference              | Calculated Size |
|----------------|---------------------------------|-----------------|
| Char           | 0x7fffffffdbbe - 0x7fffffffdbbd | 1 Byte          |
| Short          | 0x7fffffffdbc0 - 0x7fffffffdbbe | 2 Bytes         |
| Int            | 0x7fffffffdbc4 - 0x7fffffffdbc0 | 4 Bytes         |
| Float          | 0x7fffffffdbc8 - 0x7fffffffdbc4 | 4 Bytes         |
| Double         | 0x7fffffffdbd0 - 0x7fffffffdbc8 | 8 Bytes         |
| Long           | 0x7fffffffdbd8 - 0x7fffffffdbd0 | 8 Bytes         |
| Long Long      | 0x7fffffffde0 - 0x7fffffffdbd8  | 8 Bytes         |
| Long Double    | 0x7fffffffdf0 - 0x7fffffffde0   | 16 Bytes        |

### Verification with `sizeof()` Operator
To validate the results, the `sizeof()` operator was used. The sizes retrieved using `sizeof()` were consistent with the values calculated manually, confirming the accuracy of the approach.

### Assembly Insights
#### Automatic Variables
- Stored on the stack.
- Accessed using the base pointer (rbp) with offsets.
  - Example: Variable `a` at `rbp-0x4`.

#### Data Type Sizes
- `int`: 4 bytes
- `char`: 1 byte
- `float`: 4 bytes
- `double`: 8 bytes
- `long`: 8 bytes
- `short`: 2 bytes
- `long long`: 8 bytes
- `long double`: 16 bytes

## Key Observations

### Memory Layout and Addressing
- **Order of Allocation:** The memory layout does not strictly follow the order of declaration in the source code.
- **Alignment:** Variables are aligned in memory based on their size and architecture.

### Compiler Behavior
- **Optimization:** The compiler optimizes memory allocation for automatic variables, ensuring efficient use of stack space.
- **Instruction Generation:** Assembly code reflects efficient handling of variable access and arithmetic operations.

### Limitations of the Address Difference Method
- The method relies on contiguous memory allocation for variables, which may not always hold in practice due to padding and alignment.
- Results may vary across different compilers and architectures.

## Disclaimer
The sizes retrieved in this analysis might not be the same for everyone, as different compilers and architectures can lead to variations in memory allocation and alignment.

## Discussion and Conclusions
The results from this assignment provided valuable insights into memory allocation and layout in C programming. By analyzing memory addresses and calculating variable sizes, this exercise offered a deeper understanding of how the C compiler manages automatic variables. While the address difference method has limitations, it complements traditional approaches like the `sizeof()` operator and enhances knowledge of low-level memory management.

## Author
T3rminux - Ethical Hacker & Cybersecurity Professional

