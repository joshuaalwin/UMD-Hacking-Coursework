# README

## Compiler Analysis

### Author: t3rminux

### Purpose
This program explores how different constant values influence compiler optimizations for multiplication operations. By observing the assembly code generated by the GCC compiler under various optimization scenarios, this project provides insights into low-level memory management and variable addressing in C.

### Abstract
This project demonstrates a method for determining the sizes of automatic variables in C by analyzing differences in their memory addresses. It examines various data types to provide insights into memory allocation and layout in C programming. The study offers an alternative to the `sizeof()` operator, contributing to a deeper understanding of low-level memory management principles.

### Features
- Implements four functions to demonstrate multiplication by constants (12, 10, 4, and 2).
- Manual debugging approach to analyze compiler optimizations and memory allocation.
- Insights into memory layout, padding, and alignment principles in C programming.

### Code Description
The program defines the following functions:
1. **`mulBy12(int x)`**: Multiplies the input by 12.
2. **`mulBy10(int x)`**: Multiplies the input by 10.
3. **`mulBy4(int x)`**: Multiplies the input by 4.
4. **`mulBy2(int x)`**: Multiplies the input by 2.

The main function prompts the user to select one of the multiplication functions and input a number to calculate the result. 

### Compilation Instructions
Compile the program with the following command:
```bash
gcc -m32 -g -fno-stack-protector -no-pie -mpreferred-stack-boundary=2 -fno-pic -z execstack -o compiler_analysis compiler-analysis.c
```

### Execution Instructions
1. Run the compiled program:
   ```bash
   ./compiler_analysis
   ```
2. Follow the prompts to select a multiplication function and enter an integer input.
3. Observe the result printed to the console.

### Debugging and Analysis
Manual debugging is required to analyze the compiler's optimizations and memory layout. Use GDB with the following commands:

1. **Start GDB**:
   ```bash
   gdb ./compiler_analysis
   ```
2. **Set breakpoints**:
   ```bash
   break main
   break mulBy12
   break mulBy10
   break mulBy4
   break mulBy2
   ```
3. **Run the program**:
   ```bash
   run
   ```
4. **Examine memory layout**:
   Use commands like `info registers`, `x/x` (examine memory), and `disas` (disassemble) to analyze memory and assembly code.

### Results and Discussion
#### Key Observations
- Memory addresses are aligned based on data type size.
- Alignment and padding influence the layout of variables.
- Addresses of variables were successfully retrieved, and their sizes were calculated using the memory difference method.

#### Tables
##### Table I: Data Types and Addresses
| Data Type     | Address             |
|---------------|---------------------|
| Char          | 0x7fffffffdbbd      |
| Short         | 0x7fffffffdbbe      |
| Int           | 0x7fffffffdbc0      |
| Float         | 0x7fffffffdbc4      |
| Double        | 0x7fffffffdbc8      |
| Long          | 0x7fffffffdbd0      |
| Long long     | 0x7fffffffdbd8      |
| Long double   | 0x7fffffffde0       |
| Long double   | 0x7fffffffdf0       |

##### Table II: Variable Sizes Calculated by Memory Address Difference
| Data Type     | Address Difference            | Size (Bytes) |
|---------------|-------------------------------|--------------|
| Char          | 0x7fffffffdbbe - 0x7fffffffdbbd | 1            |
| Short         | 0x7fffffffdc0 - 0x7fffffffdcbe | 2            |
| Int           | 0x7fffffffdbc4 - 0x7fffffffdbc0 | 4            |
| Float         | 0x7fffffffdbc8 - 0x7fffffffdbc4 | 4            |
| Double        | 0x7fffffffdbd0 - 0x7fffffffdbc8 | 8            |
| Long          | 0x7fffffffdbd8 - 0x7fffffffdbd0 | 8            |
| Long long     | 0x7fffffffde0 - 0x7fffffffdbd8 | 8            |
| Long double   | 0x7fffffffdf0 - 0x7fffffffde0 | 16           |

#### Limitations
- Padding and alignment constraints introduce gaps between variable addresses.
- Analysis does not fully account for compiler-specific optimizations or cross-platform differences.

### Implications for C Programming
This project emphasizes the need to understand compiler-specific memory alignment and padding for efficient programming and debugging. The insights gained are valuable for systems programming and optimization.

### Future Enhancements
- Incorporate dynamic memory allocation for a broader analysis.
- Utilize tools like memory mappers to validate results.
- Extend the study to include cross-platform testing and performance benchmarks.

### Disclaimer
This program is intended for educational purposes and requires manual debugging to analyze memory and compiler optimizations. The manual approach limits automation but offers valuable insights into memory allocation and assembly-level code.


